import{h as X}from"./index-Dt07UTka.js";import{t as o,c as T,g as x,e as O,b as y,d as I,f as M}from"./en-US-Dy1UnLtf.js";import{e as _}from"./endOfMonth-CkNiGKnp.js";/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const q=X("Bell",[["path",{d:"M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9",key:"1qo2s2"}],["path",{d:"M10.3 21a1.94 1.94 0 0 0 3.4 0",key:"qgo35s"}]]);function D(n,s){const e=o(n),a=o(s),t=e.getTime()-a.getTime();return t<0?-1:t>0?1:t}function b(n){return T(n,Date.now())}function w(n,s){const e=o(n),a=o(s),t=e.getFullYear()-a.getFullYear(),f=e.getMonth()-a.getMonth();return t*12+f}function N(n){return s=>{const a=(n?Math[n]:Math.trunc)(s);return a===0?0:a}}function R(n,s){return+o(n)-+o(s)}function Y(n){const s=o(n);return s.setHours(23,59,59,999),s}function L(n){const s=o(n);return+Y(s)==+_(s)}function F(n,s){const e=o(n),a=o(s),t=D(e,a),f=Math.abs(w(e,a));let i;if(f<1)i=0;else{e.getMonth()===1&&e.getDate()>27&&e.setDate(30),e.setMonth(e.getMonth()-t*f);let r=D(e,a)===-t;L(o(n))&&f===1&&D(n,a)===1&&(r=!1),i=t*(f-Number(r))}return i===0?0:i}function H(n,s,e){const a=R(n,s)/1e3;return N(e==null?void 0:e.roundingMethod)(a)}function v(n,s,e){const a=x(),t=(e==null?void 0:e.locale)??a.locale??O,f=2520,i=D(n,s);if(isNaN(i))throw new RangeError("Invalid time value");const r=Object.assign({},e,{addSuffix:e==null?void 0:e.addSuffix,comparison:i});let m,h;i>0?(m=o(s),h=o(n)):(m=o(n),h=o(s));const l=H(h,m),S=(y(h)-y(m))/1e3,c=Math.round((l-S)/60);let d;if(c<2)return e!=null&&e.includeSeconds?l<5?t.formatDistance("lessThanXSeconds",5,r):l<10?t.formatDistance("lessThanXSeconds",10,r):l<20?t.formatDistance("lessThanXSeconds",20,r):l<40?t.formatDistance("halfAMinute",0,r):l<60?t.formatDistance("lessThanXMinutes",1,r):t.formatDistance("xMinutes",1,r):c===0?t.formatDistance("lessThanXMinutes",1,r):t.formatDistance("xMinutes",c,r);if(c<45)return t.formatDistance("xMinutes",c,r);if(c<90)return t.formatDistance("aboutXHours",1,r);if(c<I){const u=Math.round(c/60);return t.formatDistance("aboutXHours",u,r)}else{if(c<f)return t.formatDistance("xDays",1,r);if(c<M){const u=Math.round(c/I);return t.formatDistance("xDays",u,r)}else if(c<M*2)return d=Math.round(c/M),t.formatDistance("aboutXMonths",d,r)}if(d=F(h,m),d<12){const u=Math.round(c/M);return t.formatDistance("xMonths",u,r)}else{const u=d%12,g=Math.trunc(d/12);return u<3?t.formatDistance("aboutXYears",g,r):u<9?t.formatDistance("overXYears",g,r):t.formatDistance("almostXYears",g+1,r)}}function z(n,s){return v(n,b(n),s)}export{q as B,z as f};
